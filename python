Resources
=========
http://www.diveintopython.net

Reversing a list in place or in new list
========================================
>>> L =[ "one", 2, "three"]
>>> L
['one', 2, 'three']
>>> L.reverse() #reverses in place
>>> L
['three', 2, 'one']
>>> 
>>> L =[ "one", 2, "three"]
>>> L[::-1]     #returns new list
['three', 2, 'one']
>>> L
['one', 2, 'three']
>>> K = L[::-1]
>>> K
['three', 2, 'one']
>>> L =[ "one", 2, "three"]
>>> K = list(reversed(L))   #new list
>>> K
['three', 2, 'one']



Mutable vs. Immutable
=====================

x = 10
y = x
id(x) == id(y)
id(y) == id(10)
x = x+1   # because "10" is immutable, this changes x to point to "11" (also immutable), while y still points to "10"
print x, y
id(x)==id(y)    # no longer the same reference
id(x)==id(10)   # no longer the same reference
id(y)==id(10)   # these are the same reference
id(x)==id(11)   # these are the same refernece

m = list( [1,2,3,4,5])
n = m ; print "length is ", len(m)
print "are they the same object? ",; id(m)==id(n)
m.pop() # because the list is mutable, this changes the list object rather than change the reference (to an object)
print "m==n returns",  m == n, ",", ; print "length is ", len(m)  # which makes both n, m be identical again

Since everything in Python is an Object, every variable holds an object instance. When an object is initiated, it is assigned a unique object id. 

Simple put, a mutable object can be changed after it is created, and an immutable object can't. Objects of built-in types like (int, float, bool, str, tuple, unicode) are immutable. Objects of built-in types like (list, set, dict) are mutable. Custom classes are generally mutable.

Objects of built-in types like (int, float, bool, str, tuple, unicode) are immutable. Objects of built-in types like (list, set, dict) are mutable. Custom classes are generally mutable. 

Immutable objects are fundamentally expensive to “change”, because doing so involves creating a copy. Changing mutable objects is cheap.

https://medium.com/@meghamohan/mutable-and-immutable-side-of-python-c2145cf72747


Pass by Reference, by Value, and by Object (Reference)
======================================================

if you pass a parameter to a function, it is passed by object reference, that is the reference to the object itself (and not the reference to the variable)
For example,

def incrementNumber(n):
    print n
    print id(n)
    n = n+1
    print n
    print id(n)
n = 5
incrementNumber(n)
print n         # this is 5, not 6, because 5 is immutable, so inside the function a new object (the number 6) was created

def ref_demo(x):
    print "x=",x," id=",id(x)
    x=42
    print "x=",x," id=",id(x)

x = 9
id(x)
ref_demo(x)
id(x)


What methods are available for an object?
=========================================

methodList = [method for method in dir(object) if callable(getattr(object, method))]
    where object is your object
ex. 
x = [2,3,4]
xlist = [method for method in dir(x) if callable(getattr(x, method))]
    
http://www.diveintopython.net/power_of_introspection/index.html


View History in Python Interpreter
==================================
import readline
for i in range(readline.get_current_history_length()):
    print readline.get_history_item(i + 1)

or (1 liner)
import readline; print '\n'.join([str(readline.get_history_item(i)) for i in range(readline.get_current_history_length())])
https://stackoverflow.com/questions/6558765/how-do-you-see-the-entire-command-history-in-interactive-python


Need a quik dictionary for some experiments?
============================================
>>>d = {k: random.random() for k in range(100)}
>>>type(d)
<type 'dict'>


Comparing Types
===============
if you want to a class and subclass instances to show as same type, use isinstance 
https://docs.quantifiedcode.com/python-anti-patterns/readability/do_not_compare_types_use_isinstance.html
https://stackoverflow.com/questions/1549801/what-are-the-differences-between-type-and-isinstance


You need a list of comma separated emails and you have a copy of addresses from Outlook
=======================================================================================
# copy from outlook will be semi-colon separated string in this format: first last <first.last@company.com> ; etc.
>>>a = raw_input("Paste the copy from Outlook here: ") 

>>>b = a.split(";")
>>>c = ' , '.join([  b[i][ b[i].find("<")+1 : b[i].find(">") ] for i in range(len(b))   ])


Managing Python Packages
========================

#this lists all the packages that are outdated, excluding the heading "Package" and the underline "----"
#using pip 18.0 from /Library/Python/2.7/site-packages/pip (python 2.7)
pip list --outdated | awk '{ print $1 }' | grep -vwE "(----|Package)"

pip install $(pip list --outdated | awk '{ print $1 }' | grep -vwE "(----|Package)") --upgrade

#sudo .. (this might be needed)
sudo pip install $(pip list --outdated | awk '{ print $1 }' | grep -vwE "(----|Package)") --upgrade



#to see information about each module. Use --verbose also
pip show $(pip list  | awk '{ print $1 }' | grep -vE "(----|Package)" ) | less


JSON vs. Dictionaries
=====================

Not the same. JSON is a format that serializes/represents structured data as a string. A dictionary is structured data. 
https://www.reddit.com/r/learnpython/comments/4izfn9/dicts_vs_json/


Enumerate() and Iter()
======================
https://www.programiz.com/python-programming/iterator
https://www.geeksforgeeks.org/enumerate-in-python/

Iter() creates iteratOR objects from iterABLE objects
next() returns the next item from the iteratOR
(for-loops also create iterator objects)

enumerate() creates an enumerate object from iteratABLE objects
next() returns the next enumeratED object

>> a = ['one', 'two', 3, 'four']
>>> for i in a:
...     print i
... 
one
two
3
four


#Using iter() and next()
>>> c = iter(a)
>>> c
<listiterator object at 0x1014ec110>
>>> next(c)
'one'
>>> next(c)
'two'
>>> next(c)
3
>>> next(c)
'four'
>>> next(c)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration

#Using enumerate() and next()
>>> b = enumerate(a)
>>> b
<enumerate object at 0x1014e34b0>
>>> next(b)
(0, 'one')
>>> next(b)
(1, 'two')
>>> next(b)
(2, 3)
>>> next(b)
(3, 'four')
>>> next(b)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration

#iter() in for loops
>>> for i in iter(a):
...     print i
... 
one
two
3
four

#enumerate in for loops
>>> for i in enumerate(a):
...     print i
... 
(0, 'one')
(1, 'two')
(2, 3)
(3, 'four')
>>> for counter, value in enumerate(a):
...     print counter, value
... 
0 one
1 two
2 3
3 four
>>> for i in enumerate(a, 1000):        # reset the counter
...     print i
... 
(1000, 'one')
(1001, 'two')
(1002, 3)
(1003, 'four')
