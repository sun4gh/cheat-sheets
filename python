Resources
=========
http://www.diveintopython.net

Reversing a list in place or in new list
========================================
>>> L =[ "one", 2, "three"]
>>> L
['one', 2, 'three']
>>> L.reverse() #reverses in place
>>> L
['three', 2, 'one']
>>> 
>>> L =[ "one", 2, "three"]
>>> L[::-1]     #returns new list
['three', 2, 'one']
>>> L
['one', 2, 'three']
>>> K = L[::-1]
>>> K
['three', 2, 'one']
>>> L =[ "one", 2, "three"]
>>> K = list(reversed(L))   #new list
>>> K
['three', 2, 'one']


List Slicing
============
>>> x = [0,1, 'world']
>>> x 
[0, 1, 'world']
>>> x[0:2] = ['hello']      # 0th pointer is right before the 0th element, and 1th pointer is right before 1st elemetn
>>> x                       # so 0:2 grabs the 0th and 1st elements. (0:1 would be only one element) 2-0 = 2 (2 elements)
['hello', 'world']

>>> x = [0,1, 'world']
>>> x
[0, 1, 'world']
>>> x[0:2] = [ 'hello'] * 2 
>>> x
['hello', 'hello', 'world']

>>> x = [0,1, 'world']
>>> x
[0, 1, 'world']
>>> x[0:2] = [9] *2         # [9] is a list (which is iterable)
>>> x
[9, 9, 'world']

>>> x = [0,1, 'world']
>>> x
[0, 1, 'world']
>>> x[0:2] = 'hello'        # again selects the first two elements, this time replacing them with an iterable from 'hello'
>>> x
['h', 'e', 'l', 'l', 'o', 'world']

>>> x = [0,1, 'world']
>>> x
[0, 1, 'world']
>>> x[0:2] = 9              # 9 is an object, it is not iterable
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: can only assign an iterable


Mutable vs. Immutable
=====================

x = 10
y = x
id(x) == id(y)
id(y) == id(10)
x = x+1   # because "10" is immutable, this changes x to point to "11" (also immutable), while y still points to "10"
print x, y
id(x)==id(y)    # no longer the same reference
id(x)==id(10)   # no longer the same reference
id(y)==id(10)   # these are the same reference
id(x)==id(11)   # these are the same refernece

m = list( [1,2,3,4,5])
n = m ; print "length is ", len(m)
print "are they the same object? ",; id(m)==id(n)
m.pop() # because the list is mutable, this changes the list object rather than change the reference (to an object)
print "m==n returns",  m == n, ",", ; print "length is ", len(m)  # which makes both n, m be identical again

Since everything in Python is an Object, every variable holds an object instance. When an object is initiated, it is assigned a unique object id. 

Simple put, a mutable object can be changed after it is created, and an immutable object can't. Objects of built-in types like (int, float, bool, str, tuple, unicode) are immutable. Objects of built-in types like (list, set, dict) are mutable. Custom classes are generally mutable.

Objects of built-in types like (int, float, bool, str, tuple, unicode) are immutable. Objects of built-in types like (list, set, dict) are mutable. Custom classes are generally mutable. 

Immutable objects are fundamentally expensive to “change”, because doing so involves creating a copy. Changing mutable objects is cheap.

https://medium.com/@meghamohan/mutable-and-immutable-side-of-python-c2145cf72747

More on name binding on mutable objects
=======================================

>>> a = [ [1,2,3] , [4,5,6] ]
>>> for item in a:              # here we are binding the new name "item" to objects that make up the iterable list "a"
...     print item, id(item)
... 
[1, 2, 3] 4512492216      # the name "item" is bound to the same object that a[0] (or later in the loop, a[1]) are bound
[4, 5, 6] 4512613080
>>> id(a[0])
4512492216                # this is the same object as the object that "item" name was bound to
>>> id(a[1])
4512613080

>>> for item in a:
...     item = 3                # this rebinds the name "item" to 3, which means "item" is now pointing to object "3"
...     print item, id(item)    # but that does nothing to modify the list "a".
... 
3 140518349624408               # brand new object "3" 
3 140518349624408
>>> a                           # while the list hasn't changed
[[1, 2, 3], [4, 5, 6]]
 
>>> for item in a:                  # will "item" bound to a list element like a[0] mutate the a[0] object 
...     item = ['apple', 'peach']   # when "item" is rebound to a new list?
...     print item, id(item)
... 
['apple', 'peach'] 4512613296       # a new object gets created for this list of strings, and both occurences of "item" 
['apple', 'peach'] 4512613296       # in the loop point (bind) to that object
>>> a
[[1, 2, 3], [4, 5, 6]]              # but they were rebinds of the name "item" so they did not affect the original list "a".

>>> for item in a:
...     item[:] = ['apple', 'peach']    # rather than rebind "item", here we take the object pointed TO and slice it
...     print item, id(item)            # we are the 0th and 1st list elements from pointing to the 3 elements
...                                     # to now point to two other elements.
['apple', 'peach'] 4512492216
['apple', 'peach'] 4512613080
>>> a
[['apple', 'peach'], ['apple', 'peach']]    #... thereby changing the list "a" itself.
>>> id(a[0])
4512492216
>>> id(a[1])
4512613080

Now for immutable objects (tuples), inside a mutable object (a list)

>>> b = [ (1,2,3) , (4,5,6) ]
>>> for item in b:
...     print item, id(item)
... 
(1, 2, 3) 4512337184
(4, 5, 6) 4512529056
>>> for item in b:
...     item = 3                # rebinding of name "item"
...     print item, id(item)
... 
3 140518349624408
3 140518349624408
>>> b
[(1, 2, 3), (4, 5, 6)]
>>> for item in b:
...     item = (7,8,9)          # rebinding of name "item" (but no attempt to change the object pointed at by b[0], b[1]
...     print item, id(item)
... 
(7, 8, 9) 4512529296
(7, 8, 9) 4512529296
>>> b
[(1, 2, 3), (4, 5, 6)]          # which leaves b the same.



>>> for item in b:
...     item[:] = (7,8,9)       # tuples are immutable, we cannot mutate a tuple from (1,2,3) to become (7,8,9)
... 
Traceback (most recent call last):
  File "<stdin>", line 2, in <module>
TypeError: 'tuple' object does not support item assignment

>>> for count, item in enumerate(b):
...     b[count] = (7,8,9)      # this is a rebinding of an element in a list. In the list b[count] can be made to point to a new tuple
                                # very explicitly modifying the list here, we're not using "item"
...     print b[count], id(b[count])
... 
(7, 8, 9) 4512529296
(7, 8, 9) 4512529296
>>> b
[(7, 8, 9), (7, 8, 9)]          # ...which is why the list of tuples has been MODIFIED, but we haven't modified any tuples yet

>>> for count, item in enumerate(b):
...     for changeCount, newValue in enumerate( (10,11,12)):  #the function enumerate gets one argument which is a tuple, no second optional argument
...             b[count][changeCount] = newValue              #here we attempt to mutate the object pointed at 
...             print newValue, id(b[count][changeCount])     
... 
Traceback (most recent call last):
  File "<stdin>", line 3, in <module>
TypeError: 'tuple' object does not support item assignment    #but even though you can make a list element b[0] point to a brand new tuple (7,8,9) as done above,
                                                              #you cannot make the tuple's 0th element b[0][0] point to a new object

This also shows the immutability:
>>> b[0]
(7, 8, 9)
>>> b[0][0]
7
>>> b[0][0] = 5
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment

>>> for changeCount , newValue in enumerate ( (10,11,12) ):   # for clarity on what this line attempted
...     print changeCount, newValue
... 
0 10
1 11
2 12


Pass by Reference, by Value, and by Object (Reference)
======================================================

if you pass a parameter to a function, it is passed by object reference, that is the reference to the object itself (and not the reference to the variable)
For example,

def incrementNumber(n):
    print n
    print id(n)
    n = n+1
    print n
    print id(n)
n = 5
incrementNumber(n)
print n         # this is 5, not 6, because 5 is immutable, so inside the function a new object (the number 6) was created

def ref_demo(x):
    print "x=",x," id=",id(x)
    x=42
    print "x=",x," id=",id(x)

x = 9
id(x)
ref_demo(x)
id(x)


What methods are available for an object?
=========================================

methodList = [method for method in dir(object) if callable(getattr(object, method))]
    where object is your object
ex. 
x = [2,3,4]
xlist = [method for method in dir(x) if callable(getattr(x, method))]
    
http://www.diveintopython.net/power_of_introspection/index.html


View History in Python Interpreter
==================================
import readline
for i in range(readline.get_current_history_length()):
    print readline.get_history_item(i + 1)

or (1 liner)
import readline; print '\n'.join([str(readline.get_history_item(i)) for i in range(readline.get_current_history_length())])
https://stackoverflow.com/questions/6558765/how-do-you-see-the-entire-command-history-in-interactive-python


Need a quik dictionary for some experiments?
============================================
>>>d = {k: random.random() for k in range(100)}
>>>type(d)
<type 'dict'>


Comparing Types
===============
if you want to a class and subclass instances to show as same type, use isinstance 
https://docs.quantifiedcode.com/python-anti-patterns/readability/do_not_compare_types_use_isinstance.html
https://stackoverflow.com/questions/1549801/what-are-the-differences-between-type-and-isinstance


You need a list of comma separated emails and you have a copy of addresses from Outlook
=======================================================================================
# copy from outlook will be semi-colon separated string in this format: first last <first.last@company.com> ; etc.
>>>a = raw_input("Paste the copy from Outlook here: ") 

>>>b = a.split(";")
>>>c = ' , '.join([  b[i][ b[i].find("<")+1 : b[i].find(">") ] for i in range(len(b))   ])


Managing Python Packages
========================

#this lists all the packages that are outdated, excluding the heading "Package" and the underline "----"
#using pip 18.0 from /Library/Python/2.7/site-packages/pip (python 2.7)
pip list --outdated | awk '{ print $1 }' | grep -vwE "(----|Package)"

pip install $(pip list --outdated | awk '{ print $1 }' | grep -vwE "(----|Package)") --upgrade

#sudo .. (this might be needed)
sudo pip install $(pip list --outdated | awk '{ print $1 }' | grep -vwE "(----|Package)") --upgrade



#to see information about each module. Use --verbose also
pip show $(pip list  | awk '{ print $1 }' | grep -vE "(----|Package)" ) | less


JSON vs. Dictionaries
=====================

Not the same. JSON is a format that serializes/represents structured data as a string. A dictionary is structured data. 
https://www.reddit.com/r/learnpython/comments/4izfn9/dicts_vs_json/


Enumerate() and Iter()
======================
https://www.programiz.com/python-programming/iterator
https://www.geeksforgeeks.org/enumerate-in-python/

Iter() creates iteratOR objects from iterABLE objects
next() returns the next item from the iteratOR
(for-loops also create iterator objects)

enumerate() creates an enumerate object from iteratABLE objects
next() returns the next enumeratED object

>> a = ['one', 'two', 3, 'four']
>>> for i in a:
...     print i
... 
one
two
3
four


#Using iter() and next()
>>> c = iter(a)
>>> c
<listiterator object at 0x1014ec110>
>>> next(c)
'one'
>>> next(c)
'two'
>>> next(c)
3
>>> next(c)
'four'
>>> next(c)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration

#Using enumerate() and next()
>>> b = enumerate(a)
>>> b
<enumerate object at 0x1014e34b0>
>>> next(b)
(0, 'one')
>>> next(b)
(1, 'two')
>>> next(b)
(2, 3)
>>> next(b)
(3, 'four')
>>> next(b)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration

#iter() in for loops
>>> for i in iter(a):
...     print i
... 
one
two
3
four

#enumerate in for loops
>>> for i in enumerate(a):
...     print i
... 
(0, 'one')
(1, 'two')
(2, 3)
(3, 'four')
>>> for counter, value in enumerate(a):
...     print counter, value
... 
0 one
1 two
2 3
3 four
>>> for i in enumerate(a, 1000):        # reset the counter
...     print i
... 
(1000, 'one')
(1001, 'two')
(1002, 3)
(1003, 'four')
