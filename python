Resources
=========
http://www.diveintopython.net

Mutable vs. Immutable
=====================

x = 10
y = x
id(x) == id(y)
id(y) == id(10)
x = x+1   # because "10" is immutable, this changes x to point to "11" (also immutable), while y still points to "10"
print x, y
id(x)==id(y)    # no longer the same reference
id(x)==id(10)   # no longer the same reference
id(y)==id(10)   # these are the same reference
id(x)==id(11)   # these are the same refernece

m = list( [1,2,3,4,5])
n = m ; print "length is ", len(m)
print "are they the same object? ",; id(m)==id(n)
m.pop() # because the list is mutable, this changes the list object rather than change the reference (to an object)
print "m==n returns",  m == n, ",", ; print "length is ", len(m)  # which makes both n, m be identical again

Since everything in Python is an Object, every variable holds an object instance. When an object is initiated, it is assigned a unique object id. 

Simple put, a mutable object can be changed after it is created, and an immutable object can't. Objects of built-in types like (int, float, bool, str, tuple, unicode) are immutable. Objects of built-in types like (list, set, dict) are mutable. Custom classes are generally mutable.

Objects of built-in types like (int, float, bool, str, tuple, unicode) are immutable. Objects of built-in types like (list, set, dict) are mutable. Custom classes are generally mutable. 

Immutable objects are fundamentally expensive to “change”, because doing so involves creating a copy. Changing mutable objects is cheap.

https://medium.com/@meghamohan/mutable-and-immutable-side-of-python-c2145cf72747


Pass by Reference, by Value, and by Object (Reference)
======================================================

if you pass a parameter to a function, it is passed by object reference, that is the reference to the object itself (and not the reference to the variable)
For example,

def incrementNumber(n):
    print n
    print id(n)
    n = n+1
    print n
    print id(n)
n = 5
incrementNumber(n)
print n         # this is 5, not 6, because 5 is immutable, so inside the function a new object (the number 6) was created

def ref_demo(x):
    print "x=",x," id=",id(x)
    x=42
    print "x=",x," id=",id(x)

x = 9
id(x)
ref_demo(x)
id(x)


What methods are available for an object?
=========================================

methodList = [method for method in dir(object) if callable(getattr(object, method))]
    where object is your object
ex. 
x = [2,3,4]
xlist = [method for method in dir(x) if callable(getattr(x, method))]
    
http://www.diveintopython.net/power_of_introspection/index.html


View History in Python Interpreter
==================================
import readline
for i in range(readline.get_current_history_length()):
    print readline.get_history_item(i + 1)

or (1 liner)
import readline; print '\n'.join([str(readline.get_history_item(i)) for i in range(readline.get_current_history_length())])
https://stackoverflow.com/questions/6558765/how-do-you-see-the-entire-command-history-in-interactive-python


Need a quik dictionary for some experiments?
============================================
>>>d = {k: random.random() for k in range(100)}
>>>type(d)
<type 'dict'>


Comparing Types
===============
if you want to a class and subclass instances to show as same type, use isinstance 
https://docs.quantifiedcode.com/python-anti-patterns/readability/do_not_compare_types_use_isinstance.html
https://stackoverflow.com/questions/1549801/what-are-the-differences-between-type-and-isinstance


You need a list of comma separated emails and you have a copy of addresses from Outlook
=======================================================================================
# copy from outlook will be semi-colon separated string in this format: first last <first.last@company.com> ; etc.
>>>a = raw_input("Paste the copy from Outlook here: ") 

>>>b = a.split(";")
>>>c = ' , '.join([  b[i][ b[i].find("<")+1 : b[i].find(">") ] for i in range(len(b))   ])



